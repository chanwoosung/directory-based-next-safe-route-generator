import chokidar from "chokidar";
import fs from "fs/promises";
import path from "path";

export type ProjectType = "react" | "next-app" | "next-page";

interface GenerateOptions {
  root: string;
  type: ProjectType;
  out: string;
  watch?: boolean;
}

/**
 * âœ… ë¼ìš°íŠ¸ ë£¨íŠ¸ íƒìƒ‰
 */
async function resolveRootDir(base: string, type: ProjectType): Promise<string> {
  const candidates =
    type === "react"
      ? [path.join(base, "src")]
      : type === "next-app"
      ? [path.join(base, "app"), path.join(base, "src", "app")]
      : [path.join(base, "pages"), path.join(base, "src", "pages")];

  for (const c of candidates) {
    try {
      const stat = await fs.stat(c);
      if (stat.isDirectory()) return c;
    } catch {}
  }
  throw new Error(`âŒ Could not find route root for ${type}`);
}

/**
 * âœ… í´ë” ë° íŒŒì¼ì—ì„œ ë¼ìš°íŠ¸ ê²½ë¡œë¥¼ ì¶”ì¶œ (íŠ¸ë¦¬ ì—†ì´ flat)
 */
async function collectRoutes(
  dir: string,
  prefix = ""
): Promise<{ path: string; params: string[] }[]> {
  const result: { path: string; params: string[] }[] = [];

  const entries = await fs.readdir(dir, { withFileTypes: true });
  const files = entries.filter((e) => e.isFile());
  const dirs = entries.filter((e) => e.isDirectory());

  // âœ… ì´ í´ë”ì— page.tsx / index.tsx ì¡´ì¬ â†’ routeë¡œ ë“±ë¡
  const hasPage = files.some((f) => /^(page|index)\.(t|j)sx?$/.test(f.name));
  if (hasPage) {
    result.push({ path: prefix || "/", params: extractParams(prefix) });
  }

  for (const entry of dirs) {
    const name = entry.name;

    // ğŸ§© __í´ë” â†’ ì™„ì „ ë¬´ì‹œ
    if (name.startsWith("__")) continue;

    // ğŸ§© parallel route (@segment) â†’ ë¬´ì‹œ
    if (name.startsWith("@")) continue;

    // ğŸ§© intercept route (Â (..segment)Â ) â†’ pathì— ì˜í–¥ ì—†ìŒ, ë‚´ë¶€ íƒìƒ‰
    if (/^\(\.\..*\)$/.test(name)) {
      const subPath = path.join(dir, name);
      result.push(...(await collectRoutes(subPath, prefix)));
      continue;
    }

    // ğŸ§© group route ( (group) ) â†’ pathì—ëŠ” í¬í•¨í•˜ì§€ ì•Šì§€ë§Œ ë‚´ë¶€ íƒìƒ‰
    if (/^\(.*\)$/.test(name)) {
      const subPath = path.join(dir, name);
      result.push(...(await collectRoutes(subPath, prefix)));
      continue;
    }

    // ğŸ’¥ Catch-all [...slug]
    if (/^\[\.\.\..*\]$/.test(name)) {
      const param = name.slice(4, -1);
      const newPrefix = `${prefix}/${"${string}"}`;
      const subDir = path.join(dir, name);
      result.push(...(await collectRoutes(subDir, newPrefix)));
      continue;
    }

    // ğŸ’¥ Dynamic Route [id]
    if (/^\[.*\]$/.test(name)) {
      const param = name.slice(1, -1);
      const newPrefix = `${prefix}/$${param}`;
      const subDir = path.join(dir, name);
      result.push(...(await collectRoutes(subDir, newPrefix)));
      continue;
    }

    // âœ… ì¼ë°˜ í´ë”
    const safeSegment = name.replace(/-/g, "_"); // í•˜ì´í”ˆ â†’ ì–¸ë”ë°”
    const newPrefix = `${prefix}/${safeSegment}`;
    const subDir = path.join(dir, name);
    result.push(...(await collectRoutes(subDir, newPrefix)));
  }

  return result;
}

/**
 * âœ… path ë¬¸ìì—´ì˜ íŒŒë¼ë¯¸í„°($id ë“±) ì¶”ì¶œ
 */
function extractParams(p: string): string[] {
  const matches = p.match(/\$\w+/g);
  return matches ? matches.map((p) => p.slice(1)) : [];
}

/**
 * âœ… ì¸í„°í˜ì´ìŠ¤ ì´ë¦„ ì•ˆì „ ì¹˜í™˜
 */
function makeInterfaceName(routePath: string): string {
  return (
    "Route_" +
    routePath
      .replace(/[\/:$]+/g, "_")
      .replace(/_+$/, "")
      .replace(/^_/, "")
      .replace(/\$\w+/g, (p) => p)
      .replace(/-/g, "_") // í•˜ì´í”ˆ â†’ ì–¸ë”ë°”
      .replace(/[^\w_]/g, "") // ë‚˜ë¨¸ì§€ íŠ¹ìˆ˜ë¬¸ì ì •ë¦¬
  );
}

/**
 * âœ… íƒ€ì… íŒŒì¼ ë¬¸ìì—´ ìƒì„±
 */
function makeTypeFile(routes: { path: string; params: string[] }[]): string {
  const routeTypes = routes
    .map((r) => {
      const interfaceName = makeInterfaceName(r.path);
      const params =
        r.params.length > 0
          ? `params: { ${r.params.map((p) => `${p}: string`).join("; ")} };`
          : "params?: never;";

      return `export interface ${interfaceName} {
  path: "${r.path}";
  ${params}
}`;
    })
    .join("\n\n");

  const union = routes.map((r) => makeInterfaceName(r.path)).join(" | ");

  return `// Auto-generated by safe-router
// Last updated: ${new Date().toISOString()}

${routeTypes}

export type AllRoutes = ${union};
`;
}

/**
 * âœ… íƒ€ì… íŒŒì¼ ìƒì„±
 */
export async function generateTypeFile(options: GenerateOptions) {
  const { root, type, out, watch } = options;
  const routeRoot = await resolveRootDir(root, type);

  async function generate() {
    const routes = await collectRoutes(routeRoot);
    const fileContent = makeTypeFile(routes);

    await fs.mkdir(path.dirname(out), { recursive: true });
    await fs.writeFile(out, fileContent, "utf8");
    console.log(`âœ… Routes generated: ${out}`);
  }

  await generate();

  if (watch) {
    console.log(`ğŸ‘€ Watching for route changes in ${routeRoot}`);
    chokidar.watch(routeRoot, { ignoreInitial: true }).on("all", generate);
  }
}
